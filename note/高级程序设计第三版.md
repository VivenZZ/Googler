# 高级程序设计第三版
## Object类型是它所有实例的基础。
  > Object类型的任何属性和方法，都存在于更具体的实例中。即：Object类型的所有实例都包含下列属性和方法

  1. constructor： 保存着创建当前对象的函数。
  ```js
  let obj = new Object()
  console.log(obj.constructor === Object) // true
  ```
  2. hasOwnProperty(propertyName): 用于检查给定的属性在当前的对象实例中（不是对象实例的原型中）是否存在。（参数名必须是字符串，不能是变量）
  ```js
  let P = {
    name: 'viven'
  }
  let p1 = {
    age: 18
  }
  p1.__proto__ = P // 设置p1的原型是P
  // name是原型P上的属性，所以返回false
  console.log(p1.hasOwnProperty('name')) // false
  console.log(p1.hasOwnProperty('age')) // true
  ``` 
  3. isPortotypeOf(object): 用于检查传入的对象是否是对象的原型
  ```js
  let P = {
    name: 'viven'
  }
  let p1 = {
    age: 18
  }
  let p2 = {
    age: 22
  }
  p1.__proto__ = P
  // P是p1的原型 所以返回true
  console.log(P.isPrototypeOf(p1)); // true
  console.log(P.isPrototypeOf(p2)); // false
  ```
  4. propertyIsEnumerable(propertyName): 用于检查属性是否能够用for-in进行枚举。
  ```js
  // 暂无
  ```
  5. toLocaleString(): 返回对象字符串表示
  ```js
  let o = {}
  console.log(o.toLocaleString() === '[object Object]')
  ```
  6. toString(): 返回对象字符串表示
  ```js
  let o = {}
  console.log(o.toString() === '[object Object]')
  ```
  7. valueOf(): 返回对象字符串、数值和布尔表示
  ```js
  let o = {}
  console.log(o.valueOf()) // {}
  ```
  - Object是所有对象的基础，所有的对象都具有这些基本的属性和方法

## 函数的arguments 和 参数
  1. 如果没有传递和形参相对应的实参，那么那个没有获取实参的形参就会是undefined，相当于var 声明了，但是没有赋值。
  2. 函数的arguments 和 参数 是存储在独立空间的，不是引用。但是改变一个会影响另一个。
  3. 函数的参数是按数组来保存的，这个数组长度是在传递参数的时候就是固定的，如果在传入的时候传递了2个参数，那么即使在函数内部使用arguments[2] 赋值，也不能获取形参对应的数据。
  ```js
  function add(a, b) {
    arguments[1] = 10
    let c = arguments[2]
    console.log(a , b , c) 
  }
  add(2,5) // 2, 10, undefined
  add(2) // 2 undefined, undefined
  add(2,5,7) // 2, 10, 7
  ```
## 函数中的参数是按值传递的
  > 基本数据类型，大家都明白是按值传递的，但是引用类型，其实也是按值传递的。
  ```js
  let obj = new Object()
  function add(o) {
    o.name = 'viven'
  }
  add(obj)
  console.log(obj.name) // 'viven'
  ```
  * 上面的例子，看起来好像是按引用传递一样，因为我在函数内部拿到了obj，并对其进行添加属性name，在函数外的obj对象也同样有这个属性。但是看下面的例子
  ```js
  let obj = new Object()
  function add(o) {
    o.name = 'viven'
    o = new Object()
    o.name = 'kevin'
  }
  add(obj)
  console.log(obj.name) // 'viven'
  ```
  * 上面的例子打印的还是`viven`,如果参数是按引用类型来传递的话，那么外面的obj肯定会被修改成`kevin`，所以参数是按值传递的。
  * 那么大家的疑问肯定是在这里，如果不是引用传递，那么为什么函数内部修改了o的属性，函数外的obj也会有相应的属性呢？
  * <font color='red'>可以这样理解：在传递基本类型的值的时候，是按值传递。传递引用类型的时候，其实是传递的引用类型的内存地址，还是按值传。如果我们在函数内部重新定义了对象o，则是切断了当前函数内部的o的引用地址，重新赋上新的引用地址。</font>
  
  ```js
  let obj = new Object() // => 引用地址xx00xx
  function add(o) {
    o.name = 'viven' // 修改引用地址xx00xx 里面的对象
    o = new Object() // 切断xx00xx引用地址，重新赋值地址xxx000
    o.name = 'kevin' // 修改了新的引用地址xxx000里面的对象
  }
  add(obj) // 传递引用地址xx00xx 这里是按引用地址来传递的，原则上还是值传递
  console.log(obj.name) // 'viven' 获取的是xx00xx地址的对象的属性
  ```
## 